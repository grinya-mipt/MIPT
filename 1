#include <errno.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <sys/stat.h>
#include <limits.h>
#include <sys/types.h>
#include <unistd.h>
#include <wait.h>
#include <string.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <stdarg.h>

#define BUFFSIZE 500

int count_of_alocated_pointers = 0;
void** array_of_alocated_pointers = NULL;

int gz(char *file , char* source);

int copy_file(const char *src, const char *dst);

char *form_path(const char *src_path, const char *entry);

int dir_walk(const char *src, const char *dst);

int handle_next_dir(const char *src, const char *entry, const char *dst);

int handle_next_file(const char *src, const char *entry, const char *dst);

void add_pointer (void* new_pointer);

void my_error (char* message);

void free_all_pointers ();


int main(int argc, char *argv[])
{
	char *destination_path = NULL;
	char *source_path = NULL;

	umask(0);

        if (argc != 3)
                my_error("To few arguments!\n\0");

	add_pointer (source_path);
	add_pointer (destination_path);
        
        source_path = realpath(argv[1], NULL);

	if (source_path == NULL)
                my_error("realpath (src) failed\n\0");

        destination_path = realpath(argv[2], NULL);
        if (destination_path==NULL) 
                my_error("realpath(dst) failed\n\0");
        
	if ( strstr ( source_path , destination_path) != NULL) //TODO reverse order! if source is /a/b and distination is /a ,
		my_error("You can't do backup directory into yourself\n\0"); //everything is correct. but if source is /a and 
										// destination is /a/b , error will be occured!
        printf ("Backup %s --> %s\n", source_path, destination_path);

        dir_walk (source_path, destination_path); 
	
	free_all_pointers ();
        return 0;
}


int gz(char *file , char * source_file)
{
        int pid, status;
        pid=fork();
	char* bash = getenv ("SHELL");
	char* to_bash = NULL;
	
	add_pointer (to_bash);	
	to_bash = (char*) malloc ( sizeof (char) * ( strlen (file) + strlen (source_file) + strlen ("gzip <  > .gz") +1 ) ); //TODO
	strcpy ( to_bash , "gzip < \0");
	strcat (to_bash , source_file);
	strcat (to_bash , " > \0");
	strcat ( to_bash , file );
	strcat ( to_bash , ".gz\0");
        switch(pid)
        {
                case -1:
                        my_error ("fork failed\n\0");
                case 0:
                        if(execl(bash, bash, "-c" , to_bash,  NULL)==-1) //TODO
                        	my_error("execl()  failed\n\0");
                default: {
			if(waitpid(pid, &status, WUNTRACED | WCONTINUED)==-1)
                       		my_error("Error in waitpid\n\0");

                   	if(WIFEXITED(status)) 
			{
				if ( WEXITSTATUS(status) != 0 )
                       			printf("exited, status=%d\n", WEXITSTATUS(status));
                   	} 
		}
               		
       	}
	free (to_bash);
	to_bash = NULL ;
	return 0;
}



char *form_path (const char *src_path, const char *entry)
{	
	char* src_full_name = NULL;
	
	src_full_name = calloc (PATH_MAX, sizeof(char));

        if (src_full_name==NULL)
        {
         	printf("Not enought memory\n");
         	goto out;
	}
	if(sprintf(src_full_name, "%s/%s", src_path, entry)!=(strlen(src_path)+strlen(entry)+1)) 
	{
		printf("Something go wrong with sprintf, possible you have too long file name\n");
	}
out:
	return src_full_name;
}

int dir_walk (const char *src, const char *dst)
{
	DIR* dir;
	struct dirent *d_entry;
	struct stat file_info;
	char* file_name = NULL;   //TODO
	add_pointer (file_name);
	
	dir = opendir(src);
        if (dir == NULL)
		my_error("opendir failed\n\0");

	while(1)
        {


                if ((d_entry=readdir(dir))==NULL) 
		{
			if (errno!=0)
				my_error("readdir failed\n\0");	
			break;
		}
	
		
		if ((strcmp(d_entry->d_name, ".")!=0) && (strcmp(d_entry->d_name, "..")!=0)) {

			file_name = form_path (src, d_entry->d_name); //TODO

			if ( lstat ( file_name , &file_info ) != 0 )  //TODO , lstat because of avoiding linkig files
				my_error ("Can not get file information!\n\0");
			
			switch ( (file_info . st_mode) & S_IFMT) //TODO
			{
				case S_IFREG:
					if (handle_next_file(src, d_entry->d_name, dst)==1) 
					{
						my_error ("Error occured!\n\0");
					}
					break;
				case S_IFDIR:
					if (handle_next_dir(src, d_entry->d_name, dst)==1)
					{
						my_error ("Error occured!\n\0");
					}
					break;
				default:
					break;
			}
		}

		errno = 0;

		free (file_name);
		file_name = NULL;
	}


	if (closedir(dir)==-1)
                my_error ("closedir failed");

	return 0;
}

int handle_next_dir(const char *src, const char *entry, const char *dst)
{

	char* full_dst=form_path(dst, entry);
	if (full_dst==NULL)
        {
                printf("Sorry, you should make another dst_path\n");
                return 1;
        }
	char* full_src=form_path(src, entry);
	if (full_src==NULL)
        {
                printf("Sorry, you should make another src_path\n");
		return 1;
        }
        if (mkdir(full_dst, 0777) < 0)
		if (errno != EEXIST)
		       my_error ("mkdir() failed");
			
	dir_walk (full_src, full_dst);

	return 0;
}

int handle_next_file (const char *src, const char *entry, const char *dst)
{
	struct stat source_file_info , destination_file_info;
	char* zip_file = NULL;
	char* full_dst=form_path(dst, entry);
	
	if (full_dst==NULL)
	{
		printf("Sorry, you should make another dst_path\n");
		return 1;	
	}
        char* full_src=form_path(src, entry); 
        if (full_src==NULL)
        {       
                printf("Sorry, you should make another src_path\n");
                return 1;
        }

	zip_file = (char*) malloc (sizeof(char)* (strlen(full_dst)+4) );
	strcpy (zip_file,full_dst);
	strcat (zip_file,".gz\0");

	if ( stat ( zip_file , &destination_file_info) == 0) {
 		if ( stat ( full_src , &source_file_info) != 0)
			my_error ("Fatall error! Please, enter command ""rm -rf"" in terminal!\n\0");
		if (destination_file_info.st_mtime >= source_file_info.st_mtime)
			return 0;

	} else {
		if ( errno != ENOENT)
			my_error ("General failure read the disk C: !\n\0");
	}
	

	
	//copy_file ( full_src , full_dst);
	gz (full_dst , full_src); //TODO
	free(full_src);
	free(full_dst);
	return 0;
}

void add_pointer (void* new_pointer) {
	count_of_alocated_pointers ++;
	if (array_of_alocated_pointers == NULL )
		array_of_alocated_pointers = (void**) malloc (sizeof (void*) );
	else 
		array_of_alocated_pointers = (void**) realloc (array_of_alocated_pointers , count_of_alocated_pointers * sizeof (void*) );
	array_of_alocated_pointers [count_of_alocated_pointers - 1] = new_pointer;
	return;
}

void my_error (char* message) {
	int i;
	write (STDERR_FILENO, message, strlen (message));
	for (i = 0; i < count_of_alocated_pointers; ++i)
		free (array_of_alocated_pointers [i]);
	free (array_of_alocated_pointers);
	exit (-1);
}

void free_all_pointers () {
	int i;
	for (i = 0; i < count_of_alocated_pointers; ++i)
		free (array_of_alocated_pointers [i]);
	free (array_of_alocated_pointers);
	return;
}

/*int copy_file(const char *src, const char *dst) 
{
	char buf [BUFFSIZE];
	int source_fd , destination_fd;
        struct stat src_stat;
	ssize_t read_bytes;

	printf("copy file %s --> %s\n", src, dst);
	source_fd = open(src, O_RDONLY);
        if (source_fd == -1)
		my_error ("Can not open source file!\n\0");

        if (stat(src, &src_stat)==-1)
               my_error("Stat failed\n\0");
	

        destination_fd = open (dst, O_CREAT|O_WRONLY|O_TRUNC, src_stat.st_mode);
        if (destination_fd == -1) 
		my_error ("error when creating/opening destination file!\n\0");

       
        
        while ( (read_bytes = read (source_fd, buf, BUFFSIZE ) ) > 0)
	{
		if (read_bytes<0)
			my_error("Error when reading\n\0");
                if (write ( destination_fd , buf , read_bytes) != read_bytes)
                        my_error("write failed\n\0");
        }
	
	

        if ( close(source_fd) < 0 )
		my_error ("Fatal error!\n\0");
        if ( close(destination_fd) < 0 )
		my_error ("Fatal error!\n\0");

	

        return 0;
}*/
